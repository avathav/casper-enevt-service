package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"time"

	"event-service/graph/model"
	"event-service/internal/services/eventfinder"
)

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.Event, error) {
	newEvent, addErr := r.AddEventHandler.CreateEvent(ctx, ConvertNewEventToRequest(input))
	if addErr != nil {
		return nil, addErr
	}

	return ConvertEventEntryToModel(newEvent), nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEvent) (*model.Event, error) {
	updatedEvent, updateErr := r.UpdateEventHandler.UpdateEvent(ctx, ConvertEventToUpdateRequest(input))
	if updateErr != nil {
		return nil, updateErr
	}

	return ConvertEventEntryToModel(updatedEvent), nil
}

// JoinEvent is the resolver for the joinEvent field.
func (r *mutationResolver) JoinEvent(ctx context.Context, input model.Invitation) (bool, error) {
	if err := r.InvitationHandler.Join(ctx, input.Event, input.User); err != nil {
		return false, err
	}

	return true, nil
}

// InviteParticipant is the resolver for the inviteParticipant field.
func (r *mutationResolver) InviteParticipant(ctx context.Context, input model.Invitation) (bool, error) {
	if err := r.InvitationHandler.Invite(ctx, input.Event, input.User); err != nil {
		return false, err
	}

	return true, nil
}

// AcceptParticipant is the resolver for the acceptParticipant field.
func (r *mutationResolver) AcceptParticipant(ctx context.Context, input model.Invitation) (bool, error) {
	if err := r.InvitationHandler.Accept(ctx, input.Event, input.User); err != nil {
		return false, err
	}

	return true, nil
}

// RemoveParticipant is the resolver for the removeParticipant field.
func (r *mutationResolver) RemoveParticipant(ctx context.Context, input model.Invitation) (bool, error) {
	if err := r.InvitationHandler.Remove(ctx, input.Event, input.User); err != nil {
		return false, err
	}

	return true, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, user *string, name *string, public *bool, location *model.Location, upcoming *model.Upcoming) ([]*model.Event, error) {
	request := eventfinder.Request{
		User:     getValueIfNotNull(user),
		Name:     getValueIfNotNull(name),
		Location: nil,
		Upcoming: nil,
	}

	if location != nil {
		request.Location = &eventfinder.LocationRequest{
			Latitude:  *location.Latitude,
			Longitude: *location.Longitude,
			Distance:  int64(*location.Distance),
		}
	}

	if upcoming != nil {
		request.Upcoming = &eventfinder.UpcomingEventRequest{
			Date:     *upcoming.Date,
			Interval: time.Duration(*upcoming.Duration),
		}
	}

	if public != nil {
		request.Public = *public
	}

	collection, err := r.FindEventsHandler.List(ctx, request)
	if err != nil {
		return nil, err
	}

	items := make([]*model.Event, len(collection))
	for i := 0; i < len(collection); i++ {
		items[i] = ConvertEventEntryToModel(collection[i])
	}

	return items, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id *string) (*model.Event, error) {
	item, err := r.FindEventsHandler.GetByID(ctx, *id)
	if err != nil {
		return nil, err
	}

	return ConvertEventEntryToModel(item), err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
